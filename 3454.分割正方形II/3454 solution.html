<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 方法一：扫描线 + 线段树
      // 时间复杂度：O(nlogn)
      class SegmentTree {
        constructor(xs) {
          this.xs = xs; // sorted x coordinates
          this.n = xs.length - 1;
          this.count = new Array(4 * this.n).fill(0);
          this.covered = new Array(4 * this.n).fill(0);
        }

        update(qleft, qright, qval, left, right, pos) {
          if (this.xs[right + 1] <= qleft || this.xs[left] >= qright) {
            return; // no overlap
          }
          if (qleft <= this.xs[left] && this.xs[right + 1] <= qright) {
            this.count[pos] += qval;
          } else {
            const mid = Math.floor((left + right) / 2);
            this.update(qleft, qright, qval, left, mid, pos * 2 + 1);
            this.update(qleft, qright, qval, mid + 1, right, pos * 2 + 2);
          }

          if (this.count[pos] > 0) {
            this.covered[pos] = this.xs[right + 1] - this.xs[left];
          } else {
            if (left === right) {
              this.covered[pos] = 0;
            } else {
              this.covered[pos] =
                this.covered[pos * 2 + 1] + this.covered[pos * 2 + 2];
            }
          }
        }

        query() {
          return this.covered[0];
        }
      }

      var separateSquares = function (squares) {
        // 存储事件: [y坐标, 类型, 左边界, 右边界]
        const events = [];
        const xsSet = new Set();

        for (const sq of squares) {
          const [x, y, l] = sq;
          const xr = x + l;
          events.push([y, 1, x, xr]);
          events.push([y + l, -1, x, xr]);
          xsSet.add(x);
          xsSet.add(xr);
        }

        // 按y坐标排序事件
        events.sort((a, b) => a[0] - b[0]);
        // 离散化坐标
        const xs = Array.from(xsSet).sort((a, b) => a - b);
        // 初始化线段树
        const segTree = new SegmentTree(xs);

        const psum = [];
        const widths = [];
        let total_area = 0;
        let prev = events[0][0];

        // 扫描：计算总面积和记录中间状态
        for (const event of events) {
          const [y, delta, xl, xr] = event;
          const length = segTree.query();
          total_area += length * (y - prev);
          segTree.update(xl, xr, delta, 0, segTree.n - 1, 0);
          // 记录前缀和和宽度
          psum.push(total_area);
          widths.push(segTree.query());
          prev = y;
        }

        // 计算目标面积（向上取整的一半）
        const target = Math.floor((total_area + 1) / 2);
        // 二分查找第一个大于等于target的位置
        let left = 0,
          right = psum.length - 1;
        let i = 0;
        while (left <= right) {
          const mid = Math.floor((left + right) / 2);
          if (psum[mid] < target) {
            i = mid;
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }

        // 获取对应的面积、宽度和高度
        const area = psum[i];
        const width = widths[i];
        const height = events[i][0];

        return height + (total_area - area * 2) / (width * 2.0);
      };
    </script>
  </body>
</html>
