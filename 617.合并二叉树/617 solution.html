<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <script>
      // 方法一：递归
      // 时间复杂度 O(n+m)  m 和 n 分别是两个二叉树的节点个数
      // 空间复杂度 O(n+m)
      var mergeTrees = function (root1, root2) {
        if (root1 === null) return root2;
        if (root2 === null) return root1;
        return new TreeNode(
          root1.val + root2.val,
          mergeTrees(root1.left, root2.left), // 合并左子树
          mergeTrees(root1.right, root2.right)
        ); // 合并右子树
      };

      // 方法二：前序遍历
      // 时间复杂度 O(min(m,n))  m 和 n 分别是两个二叉树的节点个数
      // 空间复杂度 O(min(m,n))
      /**
       * Definition for a binary tree node.
       * function TreeNode(val) {
       *     this.val = val;
       *     this.left = this.right = null;
       * }
       */
      /**
       * @param {TreeNode} t1
       * @param {TreeNode} t2
       * @return {TreeNode}
       */
      var mergeTrees = function (t1, t2) {
        if (!t1) return t2; //若t1节点为空，那直接返回t2节点，不管t2是否为空
        if (!t2) return t1; //若t2为空，那肯定t1肯定不为空，返回t1节点
        t1.val = t1.val + t2.val; //能执行到这里证明t1与t2节点均不为空，那就两值相加，替换t1原来的值
        t1.left = mergeTrees(t1.left, t2.left); //递归遍历两者的左子树
        t1.right = mergeTrees(t1.right, t2.right); ////递归遍历两者的右左子树
        return t1; //t1必然是返回的根节点，为啥？因为都拼到t1树上了啊
      };
    </script>
  </body>
</html>
