<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 方法一：分块
      var numOfUnplacedFruits = function (fruits, baskets) {
        const n = baskets.length;
        const m = Math.floor(Math.sqrt(n));
        const section = Math.ceil(n / m);
        let count = 0;
        const maxV = new Array(section).fill(0);

        for (let i = 0; i < n; i++) {
          const sec = Math.floor(i / m);
          maxV[sec] = Math.max(maxV[sec], baskets[i]);
        }

        for (const fruit of fruits) {
          let unset = 1;
          for (let sec = 0; sec < section; sec++) {
            if (maxV[sec] < fruit) {
              continue;
            }
            let choose = 0;
            maxV[sec] = 0;
            for (let i = 0; i < m; i++) {
              const pos = sec * m + i;
              if (pos < n && baskets[pos] >= fruit && !choose) {
                baskets[pos] = 0;
                choose = 1;
              }
              if (pos < n) {
                maxV[sec] = Math.max(maxV[sec], baskets[pos]);
              }
            }
            unset = 0;
            break;
          }
          count += unset;
        }
        return count;
      };

      // 方法二：线段树 + 二分
      // 时间复杂度：O(nlogn)
      // 空间复杂度：O(n)
      class SegTree {
        constructor(baskets) {
          this.baskets = baskets;
          this.n = baskets.length;
          this.segNode = new Array(4 * this.n).fill(0);
          this.build(1, 0, this.n - 1);
        }

        build(p, l, r) {
          if (l === r) {
            this.segNode[p] = this.baskets[l];
            return;
          }
          const mid = Math.floor((l + r) / 2);
          this.build(p * 2, l, mid);
          this.build(p * 2 + 1, mid + 1, r);
          this.segNode[p] = Math.max(
            this.segNode[p * 2],
            this.segNode[p * 2 + 1]
          );
        }

        query(p, l, r, ql, qr) {
          if (ql > r || qr < l) {
            return Number.MIN_SAFE_INTEGER;
          }
          if (ql <= l && r <= qr) {
            return this.segNode[p];
          }
          const mid = Math.floor((l + r) / 2);
          return Math.max(
            this.query(p * 2, l, mid, ql, qr),
            this.query(p * 2 + 1, mid + 1, r, ql, qr)
          );
        }

        update(p, l, r, pos, val) {
          if (l === r) {
            this.segNode[p] = val;
            return;
          }
          const mid = Math.floor((l + r) / 2);
          if (pos <= mid) {
            this.update(p * 2, l, mid, pos, val);
          } else {
            this.update(p * 2 + 1, mid + 1, r, pos, val);
          }
          this.segNode[p] = Math.max(
            this.segNode[p * 2],
            this.segNode[p * 2 + 1]
          );
        }
      }

      var numOfUnplacedFruits = function (fruits, baskets) {
        const m = baskets.length;
        if (m === 0) {
          return fruits.length;
        }
        const tree = new SegTree(baskets);
        let count = 0;

        for (const fruit of fruits) {
          let l = 0,
            r = m - 1,
            res = -1;
          while (l <= r) {
            const mid = Math.floor((l + r) / 2);
            if (tree.query(1, 0, m - 1, 0, mid) >= fruit) {
              res = mid;
              r = mid - 1;
            } else {
              l = mid + 1;
            }
          }

          if (res !== -1 && tree.baskets[res] >= fruit) {
            tree.update(1, 0, m - 1, res, Number.MIN_SAFE_INTEGER);
          } else {
            count++;
          }
        }

        return count;
      };

      // test
      let fruits = [4, 2, 5],
        baskets = [3, 5, 4];
      console.log(numOfUnplacedFruits(fruits, baskets));
    </script>
  </body>
</html>
l
