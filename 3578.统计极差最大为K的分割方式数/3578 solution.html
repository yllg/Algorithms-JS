<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 方法一：滑动窗口 + 动态规划
      // 时间复杂度：O(nlogn)
      // 空间复杂度：O(n)
    //   const { AvlTree } = require("datastructures-js");

    //   var countPartitions = function (nums, k) {
    //     const n = nums.length;
    //     const mod = 1e9 + 7;
    //     const dp = new Array(n + 1).fill(0);
    //     const prefix = new Array(n + 1).fill(0);
    //     const cnt = new AvlTree();
    //     const freq = new Map();

    //     dp[0] = 1;
    //     prefix[0] = 1;

    //     for (let i = 0, j = 0; i < nums.length; i++) {
    //       const currentFreq = freq.get(nums[i]) || 0;
    //       freq.set(nums[i], currentFreq + 1);
    //       if (currentFreq === 0) {
    //         cnt.insert(nums[i]);
    //       }
    //       // 调整窗口
    //       while (j <= i && cnt.max().getValue() - cnt.min().getValue() > k) {
    //         const leftFreq = freq.get(nums[j]) || 0;
    //         freq.set(nums[j], leftFreq - 1);
    //         if (leftFreq === 1) {
    //           cnt.remove(nums[j]);
    //         }
    //         j++;
    //       }

    //       dp[i + 1] = (prefix[i] - (j > 0 ? prefix[j - 1] : 0) + mod) % mod;
    //       prefix[i + 1] = (prefix[i] + dp[i + 1]) % mod;
    //     }
    //     return dp[n];
    //   };

      // 方法二：单调队列优化
      // 时间复杂度：O(n)
      // 空间复杂度：O(n)
      var countPartitions = function (nums, k) {
        const n = nums.length;
        const mod = 1e9 + 7;
        const dp = new Array(n + 1).fill(0);
        const prefix = new Array(n + 1).fill(0);
        const minQ = [];
        const maxQ = [];

        dp[0] = 1;
        prefix[0] = 1;

        for (let i = 0, j = 0; i < n; i++) {
          // 维护最大值队列
          while (maxQ.length > 0 && nums[maxQ[maxQ.length - 1]] <= nums[i]) {
            maxQ.pop();
          }
          maxQ.push(i);
          // 维护最小值队列
          while (minQ.length > 0 && nums[minQ[minQ.length - 1]] >= nums[i]) {
            minQ.pop();
          }
          minQ.push(i);

          // 调整窗口
          while (
            maxQ.length > 0 &&
            minQ.length > 0 &&
            nums[maxQ[0]] - nums[minQ[0]] > k
          ) {
            if (maxQ[0] === j) {
              maxQ.shift();
            }
            if (minQ[0] === j) {
              minQ.shift();
            }
            j++;
          }

          const val = j > 0 ? prefix[j - 1] : 0;
          dp[i + 1] = (prefix[i] - val + mod) % mod;
          prefix[i + 1] = (prefix[i] + dp[i + 1]) % mod;
        }

        return dp[n];
      };

      // test
      let nums = [9, 4, 1, 3, 7],
        k = 4;
      console.log(countPartitions(nums, k));
    </script>
  </body>
</html>
