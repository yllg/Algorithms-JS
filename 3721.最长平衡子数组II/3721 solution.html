<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 方法一：前缀和 + 线段树
        // 时间复杂度：O(nlogn)
        // 空间复杂度：O(n)
        class LazyTag {
            constructor() {
                this.toAdd = 0;
            }

            add(other) {
                this.toAdd += other.toAdd;
                return this;
            }

            hasTag() {
                return this.toAdd !== 0;
            }

            clear() {
                this.toAdd = 0;
            }
        }

        class SegmentTreeNode {
            constructor() {
                this.minValue = 0;
                this.maxValue = 0;
                // int data = 0; // 只有叶子节点使用, 本题不需要
                this.lazyTag = new LazyTag();
            }
        }

        class SegmentTree {
            constructor(data) {
                this.n = data.length;
                this.tree = new Array(this.n * 4 + 1).fill(null).map(() => new SegmentTreeNode());
                this.build(data, 1, this.n, 1);
            }

            add(l, r, val) {
                const tag = new LazyTag();
                tag.toAdd = val;
                this.update(l, r, tag, 1, this.n, 1);
            }

            findLast(start, val) {
                if (start > this.n) {
                    return -1;
                }
                return this.find(start, this.n, val, 1, this.n, 1);
            }

            applyTag(i, tag) {
                this.tree[i].minValue += tag.toAdd;
                this.tree[i].maxValue += tag.toAdd;
                this.tree[i].lazyTag.add(tag);
            }

            pushdown(i) {
                if (this.tree[i].lazyTag.hasTag()) {
                    const tag = new LazyTag();
                    tag.toAdd = this.tree[i].lazyTag.toAdd;
                    this.applyTag(i << 1, tag);
                    this.applyTag((i << 1) | 1, tag);
                    this.tree[i].lazyTag.clear();
                }
            }

            pushup(i) {
                this.tree[i].minValue = Math.min(this.tree[i << 1].minValue, this.tree[(i << 1) | 1].minValue);
                this.tree[i].maxValue = Math.max(this.tree[i << 1].maxValue, this.tree[(i << 1) | 1].maxValue);
            }

            build(data, l, r, i) {
                if (l == r) {
                    this.tree[i].minValue = this.tree[i].maxValue = data[l - 1];
                    return;
                }

                const mid = l + ((r - l) >> 1);
                this.build(data, l, mid, i << 1);
                this.build(data, mid + 1, r, (i << 1) | 1);

                this.pushup(i);
            }

            update(targetL, targetR, tag, l, r, i) {
                if (targetL <= l && r <= targetR) {
                    this.applyTag(i, tag);
                    return;
                }

                this.pushdown(i);
                const mid = l + ((r - l) >> 1);
                if (targetL <= mid)
                    this.update(targetL, targetR, tag, l, mid, i << 1);
                if (targetR > mid)
                    this.update(targetL, targetR, tag, mid + 1, r, (i << 1) | 1);
                this.pushup(i);
            }

            find(targetL, targetR, val, l, r, i) {
                if (this.tree[i].minValue > val || this.tree[i].maxValue < val) {
                    return -1;
                }

                // 根据介值定理，此时区间内必然存在解
                if (l == r) {
                    return l;
                }

                this.pushdown(i);
                const mid = l + ((r - l) >> 1);
                // targetL 一定小于等于 r(=n)
                if (targetR >= mid + 1) {
                    const res = this.find(targetL, targetR, val, mid + 1, r, (i << 1) | 1);
                    if (res != -1)
                        return res;
                }

                if (l <= targetR && mid >= targetL) {
                    return this.find(targetL, targetR, val, l, mid, i << 1);
                }

                return -1;
            }
        }

        var longestBalanced = function (nums) {
            const occurrences = new Map();
            const sgn = (x) => (x % 2 == 0 ? 1 : -1);

            let len = 0;
            const prefixSum = new Array(nums.length).fill(0);

            prefixSum[0] = sgn(nums[0]);
            if (!occurrences.has(nums[0])) occurrences.set(nums[0], new Queue());
            occurrences.get(nums[0]).push(1);

            for (let i = 1; i < nums.length; i++) {
                prefixSum[i] = prefixSum[i - 1];
                if (!occurrences.has(nums[i]))
                    occurrences.set(nums[i], new Queue());
                const occ = occurrences.get(nums[i]);
                if (occ.size() === 0) {
                    prefixSum[i] += sgn(nums[i]);
                }
                occ.push(i + 1);
            }

            const seg = new SegmentTree(prefixSum);

            for (let i = 0; i < nums.length; i++) {
                len = Math.max(len, seg.findLast(i + len, 0) - i);

                let nextPos = nums.length + 1;
                const occ = occurrences.get(nums[i]);
                occ.pop();
                if (occ.size() > 0) {
                    nextPos = occ.front();
                }

                seg.add(i + 1, nextPos - 1, -sgn(nums[i]));
            }

            return len;
        }

    </script>
</body>

</html>