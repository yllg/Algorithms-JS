<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 方法一：优先队列 + 惰性删除
        // 时间复杂度：O(nlogn)
        // 空间复杂度：O(n)
        class Node extends DoublyLinkedListNode {
            value;
            left;
            constructor(value, left) {
                super(value);
                this.value = value;
                this.left = left;
            }
        }

        var minimumPairRemoval = function (nums) {
            const pq = new PriorityQueue((a, b) =>
                a.cost === b.cost ? a.first.left - b.first.left : a.cost - b.cost
            );

            const list = new DoublyLinkedList();
            const merged = new Array(nums.length).fill(false);
            let decreaseCount = 0;
            let count = 0;
            list.insertLast(new Node(nums[0], 0));

            for (let i = 1; i < nums.length; i++) {
                list.insertLast(new Node(nums[i], i));
                const curr = list.tail();
                pq.enqueue({
                    first: curr.getPrev(),
                    second: curr,
                    cost: nums[i] + nums[i - 1],
                });
                if (nums[i - 1] > nums[i]) {
                    decreaseCount++;
                }
            }

            while (decreaseCount > 0) {
                const { first, second, cost } = pq.dequeue();
                if (merged[first.left] || merged[second.left] || first.value + second.value !== cost)
                    continue;
                count++;

                if (first.value > second.value) {
                    decreaseCount--;
                }

                const prev = first.getPrev();
                const next = second.getNext();

                if (prev) {
                    if (prev.value > first.value && prev.value <= cost) {
                        decreaseCount--;
                    }
                    if (prev.value <= first.value && prev.value > cost) {
                        decreaseCount++;
                    }

                    pq.enqueue({
                        first: prev,
                        second: first,
                        cost: prev.value + cost,
                    });
                }

                if (next) {
                    if (second.value > next.value && cost <= next.value) {
                        decreaseCount--;
                    }
                    if (second.value <= next.value && cost > next.value) {
                        decreaseCount++;
                    }

                    pq.enqueue({
                        first: first,
                        second: next,
                        cost: cost + next.value,
                    });
                }

                list.remove(second);
                first.value = cost;
                merged[second.left] = true;
            }

            return count;
        };


        // test
        let nums = [5, 2, 3, 1]
        console.log(minimumPairRemoval(nums));
    </script>
</body>

</html>